/**
 * Structure from Motion (SfM) Obstacle Detector - Refactored Version
 * 
 * Implementa il rilevamento ostacoli usando il flusso ottico e la triangolazione.
 * Principio: oggetti più vicini si muovono più velocemente nell'immagine.
 * 
 * Autore: SmartMower Vision System
 * Data: 2025-07-24
 * Versione: 2.0 - Refactored and Optimized
 */

#include <iostream>
#include <vector>
#include <queue>
#include <string>
#include <cmath>
#include <chrono>
#include <thread>
#include <mutex>
#include <atomic>
#include <condition_variable>
#include <fstream>
#include <memory>
#include <csignal>
#include <cstdlib>
#include <algorithm>

// OpenCV headers
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/features2d.hpp>
#include <opencv2/video/tracking.hpp>
#include <fstream>
#include <sstream>

// MQTT and JSON
#include <mosquitto.h>
#include <cjson/cJSON.h>

// Vision MQTT definitions
#include "vision_obstacle.h"

/**
 * Configuration structure
 */
struct Config {
    // MQTT settings
    std::string mqtt_broker;
    int mqtt_port;
    std::string mqtt_username;
    std::string mqtt_password;
    std::string mqtt_camera_topic;
    std::string mqtt_velocity_topic;
    std::string mqtt_obstacles_topic;
    int mqtt_qos;
    bool mqtt_retain;
    
    // Camera calibration
    double focal_length_x;
    double focal_length_y;
    double principal_point_x;
    double principal_point_y;
    
    // Robot parameters
    double camera_height;
    double max_detection_range;
    double min_obstacle_distance;
    
    // SfM parameters
    int max_corners;
    double quality_level;
    double min_distance;
    int block_size;
    double harris_k;
    
    // Obstacle detection
    int min_frames_tracked;
    double max_optical_flow_error;
    int min_points_threshold;
    double displacement_threshold;
    double publish_threshold;
    
    // Debug
    bool debug_enabled;
};

/**
 * Thread-safe frame buffer
 */
class FrameBuffer {
private:
    cv::Mat frame_;
    std::chrono::system_clock::time_point timestamp_;
    mutable std::mutex mutex_;
    std::condition_variable cv_;
    bool has_new_frame_ = false;

public:
    void setFrame(const cv::Mat& frame, const std::chrono::system_clock::time_point& timestamp) {
        std::lock_guard<std::mutex> lock(mutex_);
        frame.copyTo(frame_);
        timestamp_ = timestamp;
        has_new_frame_ = true;
        cv_.notify_one();
    }
    
    bool getFrame(cv::Mat& frame, std::chrono::system_clock::time_point& timestamp) {
        std::lock_guard<std::mutex> lock(mutex_);
        if (!has_new_frame_ || frame_.empty()) {
            return false;
        }
        frame_.copyTo(frame);
        timestamp = timestamp_;
        has_new_frame_ = false;
        return true;
    }
    
    bool waitForFrame(cv::Mat& frame, std::chrono::system_clock::time_point& timestamp, 
                     std::chrono::milliseconds timeout = std::chrono::milliseconds(100)) {
        std::unique_lock<std::mutex> lock(mutex_);
        if (cv_.wait_for(lock, timeout, [this] { return has_new_frame_; })) {
            if (!frame_.empty()) {
                frame_.copyTo(frame);
                timestamp = timestamp_;
                has_new_frame_ = false;
                return true;
            }
        }
        return false;
    }
};

/**
 * Thread-safe velocity manager
 */
class VelocityManager {
private:
    std::atomic<double> current_velocity_{0.5}; // Default velocity
    mutable std::mutex mutex_;
    std::chrono::system_clock::time_point last_update_;

public:
    void setVelocity(double velocity) {
        std::lock_guard<std::mutex> lock(mutex_);
        current_velocity_.store(velocity);
        last_update_ = std::chrono::system_clock::now();
    }
    
    double getVelocity() const {
        return current_velocity_.load();
    }
    
    bool isVelocityRecent(std::chrono::seconds max_age = std::chrono::seconds(5)) const {
        std::lock_guard<std::mutex> lock(mutex_);
        auto now = std::chrono::system_clock::now();
        return (now - last_update_) < max_age;
    }
};

/**
 * Tracked point structure
 */
struct TrackedPoint {
    cv::Point2f current_pos;
    cv::Point2f previous_pos;
    double distance_estimate = 0.0;
    int frames_tracked = 0;
    bool is_valid = true;
    
    double getDisplacement() const {
        cv::Point2f diff = current_pos - previous_pos;
        return std::sqrt(diff.x * diff.x + diff.y * diff.y);
    }
};

/**
 * Base64 decoder utility
 */
class Base64Decoder {
public:
    static std::vector<uchar> decode(const std::string& base64) {
        static const std::string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        
        std::string decoded;
        int val = 0, valb = -8;
        for (char c : base64) {
            if (chars.find(c) == std::string::npos) break;
            val = (val << 6) + chars.find(c);
            valb += 6;
            if (valb >= 0) {
                decoded.push_back(char((val >> valb) & 0xFF));
                valb -= 8;
            }
        }
        
        std::vector<uchar> data;
        data.assign(decoded.begin(), decoded.end());
        return data;
    }
};

/**
 * Main SfM Obstacle Detector class - Refactored
 */
class SfMObstacleDetector {
private:
    // MQTT client
    struct mosquitto* mqtt_client_ = nullptr;
    
    // Configurazione
    Config config_;
    
    // Dichiarazioni delle funzioni di gestione MQTT
    void onMQTTMessage(const struct mosquitto_message* message);
    void onMQTTDisconnect(int result);
    void handleMQTTConnect(struct mosquitto* mosq, int result);
    
    // Wrapper statici per le callback MQTT
    static void onMQTTConnectWrapper(struct mosquitto* mosq, void* userdata, int result) {
        SfMObstacleDetector* detector = static_cast<SfMObstacleDetector*>(userdata);
        if (detector) {
            detector->handleMQTTConnect(mosq, result);
        }
    }
    
    static void onMQTTMessageWrapper(struct mosquitto* /*mosq*/, void* userdata, 
                                   const struct mosquitto_message* message) {
        SfMObstacleDetector* detector = static_cast<SfMObstacleDetector*>(userdata);
        if (detector && message) {
            detector->onMQTTMessage(message);
        }
    }
    
    static void onMQTTDisconnectWrapper(struct mosquitto* /*mosq*/, void* userdata, int result) {
        SfMObstacleDetector* detector = static_cast<SfMObstacleDetector*>(userdata);
        if (detector) {
            detector->onMQTTDisconnect(result);
        }
    }
    
    // Gestione messaggi
    void handleVelocityMessage(const struct mosquitto_message* message) {
        if (!message || !message->payload || message->payloadlen <= 0) {
            std::cerr << "[ERROR] Invalid velocity message received" << std::endl;
            return;
        }
        
        std::string payload(static_cast<const char*>(message->payload), message->payloadlen);
        cJSON* root = cJSON_Parse(payload.c_str());
        
        if (!root) {
            std::cerr << "[ERROR] Failed to parse velocity JSON" << std::endl;
            return;
        }
        
        // Estrai i dati di velocità
        cJSON* type_json = cJSON_GetObjectItem(root, "type");
        if (cJSON_IsString(type_json) && strcmp(type_json->valuestring, "fusion_data") == 0) {
            cJSON* velocity_obj = cJSON_GetObjectItem(root, "velocity");
            if (velocity_obj) {
                // Prova a ottenere la velocità diretta
                cJSON* speed_json = cJSON_GetObjectItem(velocity_obj, "speed");
                if (cJSON_IsNumber(speed_json)) {
                    double speed = speed_json->valuedouble;
                    velocity_manager_.setVelocity(speed);
                    if (config_.debug_enabled) {
                        std::cout << "[VELOCITY] Set speed: " << speed << " m/s" << std::endl;
                    }
                } else {
                    // Fallback: calcola la velocità dalle componenti vx, vy
                    cJSON* vx_json = cJSON_GetObjectItem(velocity_obj, "vx");
                    cJSON* vy_json = cJSON_GetObjectItem(velocity_obj, "vy");
                    
                    if (cJSON_IsNumber(vx_json) && cJSON_IsNumber(vy_json)) {
                        double vx = vx_json->valuedouble;
                        double vy = vy_json->valuedouble;
                        double speed = sqrt(vx * vx + vy * vy);
                        velocity_manager_.setVelocity(speed);
                        if (config_.debug_enabled) {
                            std::cout << "[VELOCITY] Calculated speed from vx/vy: " << speed << " m/s" << std::endl;
                        }
                    } else {
                        std::cerr << "[ERROR] No valid velocity components in fusion data" << std::endl;
                    }
                }
            } else {
                std::cerr << "[ERROR] No velocity object in fusion data" << std::endl;
            }
        } else if (config_.debug_enabled) {
            std::cout << "[VELOCITY] Ignoring non-fusion message type" << std::endl;
        }
        
        cJSON_Delete(root);
    }
    
    void handleImageMessage(const struct mosquitto_message* message) {
        if (!message || !message->payload || message->payloadlen <= 0) {
            std::cerr << "[ERROR] Invalid image message received" << std::endl;
            return;
        }
        
        std::string payload(static_cast<const char*>(message->payload), message->payloadlen);
        cJSON* root = cJSON_Parse(payload.c_str());
        
        if (!root) {
            std::cerr << "[ERROR] Failed to parse image JSON" << std::endl;
            return;
        }
        
        // Estrai i dati dell'immagine
        cJSON* image_data = cJSON_GetObjectItem(root, "image_data");
        if (!cJSON_IsString(image_data)) {
            std::cerr << "[ERROR] No image_data field in message" << std::endl;
            cJSON_Delete(root);
            return;
        }
        
        // Decodifica l'immagine base64
        std::string base64_data = image_data->valuestring;
        std::vector<uchar> image_buffer = Base64Decoder::decode(base64_data);
        
        if (image_buffer.empty()) {
            std::cerr << "[ERROR] Failed to decode base64 image data" << std::endl;
            cJSON_Delete(root);
            return;
        }
        
        // Decodifica l'immagine in formato OpenCV
        cv::Mat frame = cv::imdecode(image_buffer, cv::IMREAD_COLOR);
        
        if (!frame.empty()) {
            // Salva il frame nel buffer per l'elaborazione
            frame_buffer_.setFrame(frame, std::chrono::system_clock::now());
            
            // Log di debug ogni 30 frame
            if (config_.debug_enabled && (frame_count_++ % 30 == 0)) {
                std::cout << "[DEBUG] Processed frame: " << frame.cols << "x" << frame.rows 
                         << " channels: " << frame.channels() << std::endl;
            }
        } else {
            std::cerr << "[ERROR] Failed to decode image data" << std::endl;
            
            // Salva i dati grezzi per il debug in caso di errore
            if (config_.debug_enabled) {
                std::ofstream out("/tmp/last_received_frame.bin", std::ios::binary);
                if (out.is_open()) {
                    out.write(reinterpret_cast<const char*>(image_buffer.data()), image_buffer.size());
                    out.close();
                    std::cerr << "[DEBUG] Raw image data saved to /tmp/last_received_frame.bin (" 
                             << image_buffer.size() << " bytes)" << std::endl;
                } else {
                    std::cerr << "[ERROR] Failed to save debug image data" << std::endl;
                }
            }
        }
        
        cJSON_Delete(root);
    }
    
    // Threading
    std::thread processing_thread_;
    
    // Frame and velocity management
    std::atomic<bool> running_{false};
    FrameBuffer frame_buffer_;
    VelocityManager velocity_manager_;
    cv::Mat previous_frame_;
    std::chrono::system_clock::time_point previous_timestamp_;
    std::vector<TrackedPoint> tracked_points_;
    int frame_count_ = 0;
    
    // Statistics
    struct {
        std::atomic<int> frames_processed{0};
        std::atomic<int> obstacles_detected{0};
        std::atomic<double> avg_processing_time{0.0};
    } stats_;

public:
    SfMObstacleDetector() {
        // Configurazione di default
        config_.mqtt_broker = "localhost";
        config_.mqtt_port = 1883;
        config_.mqtt_username = "";
        config_.mqtt_password = "";
        config_.mqtt_camera_topic = "smartmower/vision/camera/frame";
        
        // Carica la configurazione dal file
        const char* configPath = "/opt/smartmower/etc/config/robot_config.json";
        if (!loadConfigFromFile(configPath)) {
            std::cerr << "Using default MQTT configuration" << std::endl;
        } else {
            std::cout << "MQTT configuration loaded from " << configPath << std::endl;
            std::cout << "Broker: " << config_.mqtt_broker << ":" << config_.mqtt_port << std::endl;
        }
        
        // Inizializza il client MQTT
        mosquitto_lib_init();
        mqtt_client_ = mosquitto_new(nullptr, true, this);
        
        if (!mqtt_client_) {
            throw std::runtime_error("Failed to create MQTT client");
        }
    }
    
    ~SfMObstacleDetector() {
        stop();
        if (mqtt_client_) {
            mosquitto_destroy(mqtt_client_);
        }
        mosquitto_lib_cleanup();
    }
    
    bool loadConfigFromFile(const std::string& filename) {
        std::ifstream config_file(filename);
        if (!config_file.is_open()) {
            std::cerr << "Failed to open config file: " << filename << std::endl;
            return false;
        }
        
        std::string json_str((std::istreambuf_iterator<char>(config_file)),
                            std::istreambuf_iterator<char>());
        
        cJSON* root = cJSON_Parse(json_str.c_str());
        if (!root) {
            std::cerr << "Failed to parse config file" << std::endl;
            return false;
        }
        
        // Load MQTT settings
        cJSON* mqtt = cJSON_GetObjectItem(root, "mqtt");
        if (mqtt) {
            cJSON* broker = cJSON_GetObjectItem(mqtt, "broker");
            cJSON* port = cJSON_GetObjectItem(mqtt, "port");
            cJSON* username = cJSON_GetObjectItem(mqtt, "username");
            cJSON* password = cJSON_GetObjectItem(mqtt, "password");
            cJSON* base_topic = cJSON_GetObjectItem(mqtt, "base_topic");
            
            // Get obstacle specific MQTT settings
            cJSON* topics = cJSON_GetObjectItem(mqtt, "topics");
            if (topics) {
                cJSON* obstacle = cJSON_GetObjectItem(topics, "obstacle");
                if (obstacle) {
                    // Get QoS and retain settings
                    cJSON* qos = cJSON_GetObjectItem(obstacle, "qos");
                    cJSON* retain = cJSON_GetObjectItem(obstacle, "retain");
                    
                    if (cJSON_IsNumber(qos)) {
                        config_.mqtt_qos = qos->valueint;
                    }
                    if (cJSON_IsBool(retain)) {
                        config_.mqtt_retain = cJSON_IsTrue(retain);
                    }
                    
                    // Get obstacles topic if specified
                    cJSON* subtopics = cJSON_GetObjectItem(obstacle, "subtopics");
                    if (subtopics) {
                        cJSON* obstacles_topic = cJSON_GetObjectItem(subtopics, "obstacles");
                        if (cJSON_IsString(obstacles_topic)) {
                            if (cJSON_IsString(base_topic)) {
                                config_.mqtt_obstacles_topic = std::string(base_topic->valuestring) + "/" + 
                                                             std::string(obstacles_topic->valuestring);
                            } else {
                                config_.mqtt_obstacles_topic = std::string(obstacles_topic->valuestring);
                            }
                        }
                    }
                }
            }
            
            if (cJSON_IsString(broker)) config_.mqtt_broker = broker->valuestring;
            if (cJSON_IsNumber(port)) config_.mqtt_port = port->valueint;
            if (cJSON_IsString(username)) config_.mqtt_username = username->valuestring;
            if (cJSON_IsString(password)) config_.mqtt_password = password->valuestring;
        }
        
        // Load camera height from root camera section
        cJSON* camera_root = cJSON_GetObjectItem(root, "camera");
        if (camera_root) {
            cJSON* height = cJSON_GetObjectItem(camera_root, "height_m");
            if (cJSON_IsNumber(height)) {
                config_.camera_height = height->valuedouble;
            }
        }
            
        // Load vision configuration
        cJSON* vision = cJSON_GetObjectItem(root, "vision_config");
        if (vision) {
            // Load camera intrinsics
            cJSON* camera = cJSON_GetObjectItem(vision, "camera");
            if (camera) {
                cJSON* intrinsics = cJSON_GetObjectItem(camera, "intrinsics");
                if (intrinsics) {
                    cJSON* fx = cJSON_GetObjectItem(intrinsics, "focal_length_x");
                    cJSON* fy = cJSON_GetObjectItem(intrinsics, "focal_length_y");
                    cJSON* cx = cJSON_GetObjectItem(intrinsics, "principal_point_x");
                    cJSON* cy = cJSON_GetObjectItem(intrinsics, "principal_point_y");
                    
                    if (cJSON_IsNumber(fx)) config_.focal_length_x = fx->valuedouble;
                    if (cJSON_IsNumber(fy)) config_.focal_length_y = fy->valuedouble;
                    if (cJSON_IsNumber(cx)) config_.principal_point_x = cx->valuedouble;
                    if (cJSON_IsNumber(cy)) config_.principal_point_y = cy->valuedouble;
                }
            }
            
            // Load obstacle detection parameters
            cJSON* detection = cJSON_GetObjectItem(vision, "detection");
            if (detection) {
                cJSON* obstacle_detection = cJSON_GetObjectItem(detection, "obstacle_detection");
                if (obstacle_detection) {
                    // Load general parameters
                    cJSON* params = cJSON_GetObjectItem(obstacle_detection, "parameters");
                    if (params) {
                        cJSON* max_range = cJSON_GetObjectItem(params, "max_detection_range");
                        cJSON* min_dist = cJSON_GetObjectItem(params, "min_obstacle_distance");
                        cJSON* cam_height = cJSON_GetObjectItem(params, "camera_height");
                        cJSON* min_points = cJSON_GetObjectItem(params, "min_points_threshold");
                        cJSON* disp_thresh = cJSON_GetObjectItem(params, "displacement_threshold");
                        cJSON* pub_thresh = cJSON_GetObjectItem(params, "publish_threshold");
                        
                        if (cJSON_IsNumber(max_range)) config_.max_detection_range = max_range->valuedouble;
                        if (cJSON_IsNumber(min_dist)) config_.min_obstacle_distance = min_dist->valuedouble;
                        if (cJSON_IsNumber(cam_height)) config_.camera_height = cam_height->valuedouble;
                        if (cJSON_IsNumber(min_points)) config_.min_points_threshold = min_points->valueint;
                        if (cJSON_IsNumber(disp_thresh)) config_.displacement_threshold = disp_thresh->valuedouble;
                        if (cJSON_IsNumber(pub_thresh)) config_.publish_threshold = pub_thresh->valuedouble;
                    }
                    
                    // Load SfM parameters
                    cJSON* sfm_params = cJSON_GetObjectItem(obstacle_detection, "sfm_parameters");
                    if (sfm_params) {
                        cJSON* max_corners = cJSON_GetObjectItem(sfm_params, "max_corners");
                        cJSON* quality = cJSON_GetObjectItem(sfm_params, "quality_level");
                        cJSON* min_dist = cJSON_GetObjectItem(sfm_params, "min_distance");
                        cJSON* block_size = cJSON_GetObjectItem(sfm_params, "block_size");
                        cJSON* harris_k = cJSON_GetObjectItem(sfm_params, "harris_k");
                        cJSON* min_frames = cJSON_GetObjectItem(sfm_params, "min_track_frames");
                        cJSON* max_error = cJSON_GetObjectItem(sfm_params, "max_optical_flow_error");
                        
                        if (cJSON_IsNumber(max_corners)) config_.max_corners = max_corners->valueint;
                        if (cJSON_IsNumber(quality)) config_.quality_level = quality->valuedouble;
                        if (cJSON_IsNumber(min_dist)) config_.min_distance = min_dist->valuedouble;
                        if (cJSON_IsNumber(block_size)) config_.block_size = block_size->valueint;
                        if (cJSON_IsNumber(harris_k)) config_.harris_k = harris_k->valuedouble;
                        if (cJSON_IsNumber(min_frames)) config_.min_frames_tracked = min_frames->valueint;
                        if (cJSON_IsNumber(max_error)) config_.max_optical_flow_error = max_error->valuedouble;
                    }
                }
            }
        }
        
        if (root) {
            ::cJSON_Delete(root);
            root = nullptr;
        }
        return true;
    }
    
    bool initialize() {
        // Set default values if not configured
        if (config_.mqtt_broker.empty()) config_.mqtt_broker = "localhost";
        if (config_.mqtt_port == 0) config_.mqtt_port = 1883;
        if (config_.mqtt_camera_topic.empty()) config_.mqtt_camera_topic = "smartmower/vision/camera";
        if (config_.mqtt_velocity_topic.empty()) config_.mqtt_velocity_topic = "smartmower/fusion/data";
        if (config_.mqtt_obstacles_topic.empty()) config_.mqtt_obstacles_topic = "smartmower/vision/obstacles";
        if (config_.mqtt_qos == 0) config_.mqtt_qos = 1;
        
        // Camera defaults
        if (config_.focal_length_x == 0) config_.focal_length_x = 350.0;
        if (config_.focal_length_y == 0) config_.focal_length_y = 350.0;
        if (config_.principal_point_x == 0) config_.principal_point_x = 320.0;
        if (config_.principal_point_y == 0) config_.principal_point_y = 240.0;
        
        // Robot defaults
        if (config_.camera_height == 0) config_.camera_height = 0.3;
        if (config_.max_detection_range == 0) config_.max_detection_range = 5.0;
        if (config_.min_obstacle_distance == 0) config_.min_obstacle_distance = 0.1;
        
        // SfM defaults
        if (config_.max_corners == 0) config_.max_corners = 150;
        if (config_.quality_level == 0) config_.quality_level = 0.005;
        if (config_.min_distance == 0) config_.min_distance = 15.0;
        if (config_.block_size == 0) config_.block_size = 5;
        if (config_.harris_k == 0) config_.harris_k = 0.04;
        
        // Obstacle detection defaults
        if (config_.min_frames_tracked == 0) config_.min_frames_tracked = 2;
        if (config_.max_optical_flow_error == 0) config_.max_optical_flow_error = 150.0;
        if (config_.min_points_threshold == 0) config_.min_points_threshold = 70;
        if (config_.displacement_threshold == 0) config_.displacement_threshold = 0.08;
        if (config_.publish_threshold == 0) config_.publish_threshold = 0.08;
        
        if (!setupMQTT()) {
            return false;
        }
        
        std::cout << "SfM Obstacle Detector initialized successfully" << std::endl;
        std::cout << "=== Configuration ===" << std::endl;
        std::cout << "MQTT Broker: " << config_.mqtt_broker << ":" << config_.mqtt_port << std::endl;
        std::cout << "MQTT Topics:" << std::endl;
        std::cout << "  Camera: " << config_.mqtt_camera_topic << std::endl;
        std::cout << "  Velocity: " << config_.mqtt_velocity_topic << std::endl;
        std::cout << "  Obstacles: " << config_.mqtt_obstacles_topic << std::endl;
        return true;
    }

    bool setupMQTT() {
        // Configura le callback MQTT
        mosquitto_connect_callback_set(mqtt_client_, onMQTTConnectWrapper);
        mosquitto_message_callback_set(mqtt_client_, onMQTTMessageWrapper);
        mosquitto_disconnect_callback_set(mqtt_client_, onMQTTDisconnectWrapper);
        
        // Configura le credenziali MQTT se presenti
        if (!config_.mqtt_username.empty() && !config_.mqtt_password.empty()) {
            mosquitto_username_pw_set(mqtt_client_, 
                                    config_.mqtt_username.c_str(), 
                                    config_.mqtt_password.c_str());
        }
        
        // Connessione al broker
        int keepalive = 60;
        int rc = mosquitto_connect(mqtt_client_, 
                                 config_.mqtt_broker.c_str(), 
                                 config_.mqtt_port, 
                                 keepalive);
        
        if (rc != MOSQ_ERR_SUCCESS) {
            std::cerr << "Failed to connect to MQTT broker: " << mosquitto_strerror(rc) << std::endl;
            throw std::runtime_error("Failed to connect to MQTT broker");
        }
        
        return true;
    }
    
    void start() {
        if (running_.load()) {
            return;
        }
        
        std::cout << "Connected to MQTT broker at " << config_.mqtt_broker << ":" << config_.mqtt_port << std::endl;
        
        running_.store(true);
        processing_thread_ = std::thread(&SfMObstacleDetector::processingLoop, this);
        
        std::cout << "SfM Obstacle Detector started" << std::endl;
    }
    
    void stop() {
        if (!running_.load()) {
            return;
        }
        
        running_.store(false);
        
        if (processing_thread_.joinable()) {
            processing_thread_.join();
        }
        
        if (mqtt_client_) {
            mosquitto_disconnect(mqtt_client_);
        }
        
        std::cout << "SfM Obstacle Detector stopped" << std::endl;
        printStatistics();
    }
    
private:
    void processingLoop() {
        mosquitto_loop_start(mqtt_client_);
        
        cv::Mat current_frame, previous_frame;
        std::chrono::system_clock::time_point current_timestamp, previous_timestamp;
        
        while (running_.load()) {
            // Wait for new frame with timeout
            if (!frame_buffer_.waitForFrame(current_frame, current_timestamp, std::chrono::milliseconds(100))) {
                continue;
            }
            
            auto start_time = std::chrono::high_resolution_clock::now();
            
            try {
                processFrame(current_frame, current_timestamp, previous_frame, previous_timestamp);
                
                // Update for next iteration
                current_frame.copyTo(previous_frame);
                previous_timestamp = current_timestamp;
                
                stats_.frames_processed++;
                
            } catch (const std::exception& e) {
                std::cerr << "[ERROR] Exception in processing loop: " << e.what() << std::endl;
            }
            
            // Update processing time statistics
            auto end_time = std::chrono::high_resolution_clock::now();
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
            stats_.avg_processing_time.store(duration.count());
            
            // Show debug window if enabled
            if (config_.debug_enabled) {
                cv::namedWindow("SfM Obstacle Detector", cv::WINDOW_NORMAL);
                cv::resizeWindow("SfM Obstacle Detector", 800, 600);
                cv::imshow("SfM Obstacle Detector", current_frame);
                
                int key = cv::waitKey(1);
                if (key == 27) { // ESC
                    running_.store(false);
                    break;
                }
            }
        }
        
        mosquitto_loop_stop(mqtt_client_, true);
    }
    
    void processFrame(const cv::Mat& current_frame, 
                     const std::chrono::system_clock::time_point& current_timestamp,
                     const cv::Mat& previous_frame,
                     const std::chrono::system_clock::time_point& previous_timestamp) {
        
        if (previous_frame.empty()) {
            if (config_.debug_enabled) {
                std::cout << "First frame received, initializing..." << std::endl;
            }
            return;
        }
        
        // Calculate time difference
        auto dt = std::chrono::duration_cast<std::chrono::duration<double>>(
            current_timestamp - previous_timestamp).count();
        
        if (dt <= 0 || dt > 1.0) { // Skip if time difference is invalid
            return;
        }
        
        // Get current velocity
        double velocity = velocity_manager_.getVelocity();
        double baseline = velocity * dt;
        
        if (config_.debug_enabled) {
            std::cout << "Processing frame - Velocity: " << velocity 
                      << " m/s, dt: " << dt << " s, Baseline: " << baseline << " m" << std::endl;
        }
        
        // Detect and track features
        std::vector<cv::Point2f> prev_points, curr_points;
        detectFeatures(previous_frame, prev_points);
        
        if (prev_points.empty()) {
            return;
        }
        
        // Track features using optical flow
        std::vector<uchar> status;
        std::vector<float> error;
        cv::calcOpticalFlowPyrLK(previous_frame, current_frame, prev_points, curr_points, status, error);
        
        // Calculate distances and filter obstacles
        std::vector<TrackedPoint> valid_obstacles;
        for (size_t i = 0; i < prev_points.size(); ++i) {
            if (status[i] && error[i] < config_.max_optical_flow_error) {
                TrackedPoint point;
                point.previous_pos = prev_points[i];
                point.current_pos = curr_points[i];
                point.frames_tracked = 1;
                
                double displacement = point.getDisplacement();
                if (displacement > config_.publish_threshold) {
                    // Calculate distance using triangulation
                    point.distance_estimate = (config_.focal_length_x * baseline) / displacement;
                    
                    // Filter by distance range
                    if (point.distance_estimate >= config_.min_obstacle_distance && 
                        point.distance_estimate <= config_.max_detection_range) {
                        valid_obstacles.push_back(point);
                    }
                }
            }
        }
        
        if (config_.debug_enabled) {
            std::cout << "Valid obstacles detected: " << valid_obstacles.size() << std::endl;
        }
        
        // Publish obstacles
        publishObstacles(valid_obstacles, velocity);
        stats_.obstacles_detected.store(valid_obstacles.size());
    }
    
    void detectFeatures(const cv::Mat& frame, std::vector<cv::Point2f>& points) {
        cv::Mat gray;
        if (frame.channels() == 3) {
            cv::cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
        } else {
            gray = frame;
        }
        
        cv::goodFeaturesToTrack(gray, points, config_.max_corners, config_.quality_level,
                               config_.min_distance, cv::Mat(), config_.block_size, 
                               false, config_.harris_k);
    }
    
    void publishObstacles(const std::vector<TrackedPoint>& obstacles, double velocity) {
        if (obstacles.empty()) {
            return;
        }
        
        // Verifica la connessione prima di pubblicare
        ensureConnected();
        
        // Create JSON message
        cJSON* root = cJSON_CreateObject();
        cJSON* obstacles_array = cJSON_CreateArray();
        
        for (const auto& obstacle : obstacles) {
            cJSON* obs = cJSON_CreateObject();
            cJSON_AddNumberToObject(obs, "distance", obstacle.distance_estimate);
            cJSON_AddNumberToObject(obs, "x", obstacle.current_pos.x);
            cJSON_AddNumberToObject(obs, "y", obstacle.current_pos.y);
            cJSON_AddItemToArray(obstacles_array, obs);
        }
        
        cJSON_AddItemToObject(root, "obstacles", obstacles_array);
        cJSON_AddNumberToObject(root, "velocity", velocity);
        cJSON_AddNumberToObject(root, "count", obstacles.size());
        
        // Get current timestamp
        auto now = std::chrono::system_clock::now();
        auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
        cJSON_AddNumberToObject(root, "timestamp", timestamp);
        
        char* json_string = cJSON_Print(root);
        
        // Publish to MQTT
        mosquitto_publish(mqtt_client_, nullptr, 
                               config_.mqtt_obstacles_topic.c_str(), 
                               strlen(json_string), json_string, 
                               config_.mqtt_qos, config_.mqtt_retain);
        
        if (config_.debug_enabled) {
            std::cout << "Published " << obstacles.size() << " obstacles with velocity: " << velocity << " m/s" << std::endl;
        }
        
        free(json_string);
        if (root) {
            ::cJSON_Delete(root);
            root = nullptr;
        }
    }
    
    void ensureConnected() {
        if (!mosquitto_loop(mqtt_client_, 0, 1)) {
            // Connessione attiva
            return;
        }
        
        // Tentativo di riconnessione
        std::cerr << "MQTT connection lost. Attempting to reconnect..." << std::endl;
        
        // Distruggi il vecchio client
        mosquitto_destroy(mqtt_client_);
        
        // Crea un nuovo client
        mqtt_client_ = mosquitto_new(nullptr, true, this);
        if (!mqtt_client_) {
            std::cerr << "Failed to create new MQTT client" << std::endl;
            return;
        }
        
        // Reimposta le callback
        mosquitto_connect_callback_set(mqtt_client_, onMQTTConnectWrapper);
        mosquitto_message_callback_set(mqtt_client_, onMQTTMessageWrapper);
        mosquitto_disconnect_callback_set(mqtt_client_, onMQTTDisconnectWrapper);
        
        // Reimposta le credenziali se presenti
        if (!config_.mqtt_username.empty() && !config_.mqtt_password.empty()) {
            mosquitto_username_pw_set(mqtt_client_, 
                                    config_.mqtt_username.c_str(), 
                                    config_.mqtt_password.c_str());
        }
        
        // Tentativo di riconnessione
        int keepalive = 60;
        int rc = mosquitto_connect(mqtt_client_, 
                                 config_.mqtt_broker.c_str(), 
                                 config_.mqtt_port, 
                                 keepalive);
        
        if (rc != MOSQ_ERR_SUCCESS) {
            std::cerr << "Failed to reconnect to MQTT broker: " << mosquitto_strerror(rc) << std::endl;
        } else {
            std::cout << "Successfully reconnected to MQTT broker" << std::endl;
        }
    }
    
    void printStatistics() {
        std::cout << "\n=== SfM Obstacle Detector Statistics ===" << std::endl;
        std::cout << "Frames processed: " << stats_.frames_processed.load() << std::endl;
        std::cout << "Obstacles detected: " << stats_.obstacles_detected.load() << std::endl;
        std::cout << "Avg processing time: " << stats_.avg_processing_time.load() << " ms" << std::endl;
        std::cout << "Velocity updates received: " << (velocity_manager_.isVelocityRecent() ? "Recent" : "Old/None") << std::endl;
    }
    

    
    // Gestore effettivo della connessione MQTT
    void handleMQTTConnect(struct mosquitto* mosq, int result) {
        if (result == 0) {
            // Sottoscrizione ai topic con logging ridotto
            int camera_result = mosquitto_subscribe(mosq, nullptr, config_.mqtt_camera_topic.c_str(), 0);
            int velocity_result = mosquitto_subscribe(mosq, nullptr, config_.mqtt_velocity_topic.c_str(), 0);
            
            if (camera_result != MOSQ_ERR_SUCCESS || velocity_result != MOSQ_ERR_SUCCESS) {
                std::cerr << "[ERROR] Failed to subscribe to MQTT topics" << std::endl;
            } else if (config_.debug_enabled) {
                std::cout << "[MQTT] Successfully subscribed to topics" << std::endl;
            }
        } else {
            std::cerr << "[ERROR] Failed to connect to MQTT broker: " << mosquitto_strerror(result) << std::endl;
        }
    }
    
    // Wrapper per la callback di connessione MQTT
    static void onMQTTConnectWrapper(struct mosquitto* mosq, void* userdata, int result) {
        SfMObstacleDetector* detector = static_cast<SfMObstacleDetector*>(userdata);
        if (detector) {
            detector->handleMQTTConnect(mosq, result);
        }
    }
    
    // Wrapper per la callback di ricezione messaggi MQTT
    static void onMQTTMessageWrapper(struct mosquitto* /*mosq*/, void* userdata, 
                                   const struct mosquitto_message* message) {
        SfMObstacleDetector* detector = static_cast<SfMObstacleDetector*>(userdata);
        if (detector && message) {
            detector->onMQTTMessage(message);
        }
    }
    
    // Wrapper per la callback di disconnessione MQTT
    static void onMQTTDisconnectWrapper(struct mosquitto* /*mosq*/, void* userdata, int result) {
        SfMObstacleDetector* detector = static_cast<SfMObstacleDetector*>(userdata);
        if (detector) {
            detector->onMQTTDisconnect(result);
        }
    }
    

    

    

    
    void onMQTTMessage(const struct mosquitto_message* message) {
        if (!message || !message->payload || message->payloadlen <= 0) {
            std::cerr << "[ERROR] Invalid MQTT message received" << std::endl;
            return;
        }
        
        std::string payload(static_cast<const char*>(message->payload), message->payloadlen);
        
        // Rimuovi eventuali caratteri di newline o spazi all'inizio/fine
        payload.erase(0, payload.find_first_not_of(" \n\r\t"));
        payload.erase(payload.find_last_not_of(" \n\r\t") + 1);
        
        if (payload.empty()) {
            std::cerr << "[ERROR] Empty payload in MQTT message" << std::endl;
            return;
        }
        
        // Determina il tipo di messaggio in base al topic
        std::string topic = message->topic ? message->topic : "";
        
        try {
            if (topic == config_.mqtt_camera_topic) {
                handleImageMessage(message);
            } else if (topic == config_.mqtt_velocity_topic) {
                handleVelocityMessage(message);
            } else if (config_.debug_enabled) {
                std::cout << "[DEBUG] Received message on topic: " << topic << std::endl;
            }
        } catch (const std::exception& e) {
            std::cerr << "[ERROR] Exception in MQTT message handler: " << e.what() << std::endl;
        }
    // Gestore effettivo della disconnessione MQTT
    void handleMQTTDisconnect(int result) {
        if (config_.debug_enabled) {
            std::cout << "[MQTT] Disconnected from broker: " << mosquitto_strerror(result) << std::endl;
        }
    }
    
    void handleImageMessage(const struct mosquitto_message* message) {
        if (!message || !message->payload || message->payloadlen <= 0) {
            std::cerr << "[ERROR] Invalid MQTT message received" << std::endl;
            return;
{{ ... }}
        
        std::string payload(static_cast<char*>(message->payload), message->payloadlen);
        
        // Rimuovi eventuali caratteri di newline o spazi all'inizio/fine
        payload.erase(0, payload.find_first_not_of(" \n\r\t"));
        payload.erase(payload.find_last_not_of(" \n\r\t") + 1);
        
        if (payload.empty()) {
            std::cerr << "[ERROR] Empty payload in MQTT message" << std::endl;
            return;
        }
        
        if (payload[0] != '{') {
            std::cerr << "[ERROR] Invalid JSON payload (does not start with '{')" << std::endl;
            return;
        }
        
        cJSON* root = cJSON_Parse(payload.c_str());
        if (!root) {
            std::cerr << "[ERROR] Failed to parse JSON message" << std::endl;
            return;
        }
        
        // Estrai i dati dell'immagine
        cJSON* image_data = cJSON_GetObjectItem(root, "image_data");
        if (!cJSON_IsString(image_data)) {
            std::cerr << "[ERROR] No image_data field in message" << std::endl;
            if (root) {
            ::cJSON_Delete(root);
            root = nullptr;
        }
            return;
        }
        
        // Decodifica l'immagine base64
        std::string base64_data = image_data->valuestring;
        std::vector<uchar> image_buffer = Base64Decoder::decode(base64_data);
        
        if (image_buffer.empty()) {
            std::cerr << "[ERROR] Failed to decode base64 image data" << std::endl;
            if (root) {
            ::cJSON_Delete(root);
            root = nullptr;
        }
            return;
        }
        
        // Decodifica l'immagine JPEG in OpenCV
        cv::Mat frame = cv::imdecode(image_buffer, cv::IMREAD_COLOR);
        
        if (!frame.empty()) {
            frame_buffer_.setFrame(frame, std::chrono::system_clock::now());
            
            if (config_.debug_enabled && (frame_count_++ % 30 == 0)) {
                std::cout << "[DEBUG] Processed frame: " << frame.cols << "x" << frame.rows 
                         << " channels: " << frame.channels() << std::endl;
            }
        } else {
            std::cerr << "[ERROR] Failed to decode image data" << std::endl;
            if (config_.debug_enabled) {
                // Salva i dati grezzi per debug
                std::ofstream out("/tmp/last_received_frame.bin", std::ios::binary);
                if (out.is_open()) {
                    out.write(reinterpret_cast<const char*>(image_buffer.data()), image_buffer.size());
                    out.close();
                    std::cerr << "[DEBUG] Raw image data saved to /tmp/last_received_frame.bin (" 
                             << image_buffer.size() << " bytes)" << std::endl;
                } else {
                    std::cerr << "[ERROR] Failed to save debug image data" << std::endl;
                }
            }
        }
        
        if (root) {
            ::cJSON_Delete(root);
            root = nullptr;
        }
    }
};

// Signal handler for graceful shutdown
std::unique_ptr<SfMObstacleDetector> g_detector;

void signalHandler(int signal) {
    std::cout << "\nReceived signal " << signal << ", shutting down..." << std::endl;
    if (g_detector) {
        g_detector->stop();
    }
    exit(0);
}

int main(int /*argc*/, char** /*argv*/) {
    // Setup signal handlers
    signal(SIGINT, signalHandler);
    signal(SIGTERM, signalHandler);
    
    try {
        g_detector = std::make_unique<SfMObstacleDetector>();
        
        if (!g_detector->initialize()) {
            std::cerr << "Failed to initialize SfM Obstacle Detector" << std::endl;
            return 1;
        }
        
        g_detector->start();
        
        // Keep main thread alive
        while (true) {
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
